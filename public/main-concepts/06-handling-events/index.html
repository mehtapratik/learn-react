<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1, minimum-scale=1.0"
      />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />

      <title>Handling Events | Main Concepts | Learn React</title>
      <link
         href="/dist/main-concepts/06-handling-events/app.css"
         rel="stylesheet"
      />
   </head>

   <body>
      <main class="stage" id="root">
         <h1>Handling Events</h1>
         <p class="intro">
            Handling events with React elements is very similar to handling
            events on DOM elements. There are some syntax differences:
         </p>
         <ul>
            <li>
               React events are named using camelCase, rather than lowercase.
            </li>
            <li>
               With JSX you pass a function as the event handler, rather than a
               string.
            </li>
            <li>
               Another difference is that you cannot return false to prevent
               default behavior in React. You must call preventDefault
               explicitly.
            </li>
         </ul>
         <pre id="codeDOMvsJSX"></pre>
         <p>
            In React, e is a synthetic event. React defines these synthetic
            events according to the W3C spec, so you don’t need to worry about
            cross-browser compatibility.
         </p>
         <p>
            When using React, you generally don’t need to call addEventListener
            to add listeners to a DOM element after it is created. Instead, just
            provide a listener when the element is initially rendered.
         </p>
         <h2>Binding "this"</h2>
         <p>
            You have to be careful about the meaning of this in JSX callbacks.
            In JavaScript, class methods are not bound by default. If you forget
            to bind this.handleClick and pass it to onClick, this will be
            undefined when the function is actually called.
         </p>
         <p>
            This is not React-specific behavior; it is a part of how functions
            work in JavaScript. Generally, if you refer to a method without ()
            after it, such as onClick={this.handleClick}, you should bind that
            method.
         </p>
         <p>
            If calling bind annoys you, there are two ways you can get around
            this: 1) Using experimental public class field syntax, or 2) using
            arrow function callback.
         </p>
         <pre id="codeBindingThis"></pre>
         <p>
            The problem with this syntax is that a different callback is created
            each time the LoggingButton renders. In most cases, this is fine.
            However, if this callback is passed as a prop to lower components,
            those components might do an extra re-rendering. We generally
            recommend binding in the constructor or using the class fields
            syntax, to avoid this sort of performance problem.
         </p>
         <h2>Passing arguments to event handlers</h2>
         <pre id="codePassingArgs"></pre>
         <p>
            The above two lines are equivalent, and use arrow functions and
            Function.prototype.bind respectively.
         </p>
         <p>
            In both cases, the e argument representing the React event will be
            passed as a second argument after the ID. With an arrow function, we
            have to pass it explicitly, but with bind any further arguments are
            automatically forwarded.
         </p>
      </main>

      <noscript>
         You need to enable JavaScript to run this app.
      </noscript>
      <script src="/dist/main-concepts/06-handling-events/app.js"></script>
   </body>
</html>
